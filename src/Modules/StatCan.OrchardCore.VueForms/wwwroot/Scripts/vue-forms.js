/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

// register VeeValidate components globally
Vue.component('validation-provider', VeeValidate.ValidationProvider);
Vue.component('validation-observer', VeeValidate.ValidationObserver); // include default english and french translations.

VeeValidate.localize({
  en: {
    "code": "en",
    "messages": {
      "alpha": "The {_field_} field may only contain alphabetic characters",
      "alpha_num": "The {_field_} field may only contain alpha-numeric characters",
      "alpha_dash": "The {_field_} field may contain alpha-numeric characters as well as dashes and underscores",
      "alpha_spaces": "The {_field_} field may only contain alphabetic characters as well as spaces",
      "between": "The {_field_} field must be between {min} and {max}",
      "confirmed": "The {_field_} field confirmation does not match",
      "digits": "The {_field_} field must be numeric and exactly contain {length} digits",
      "dimensions": "The {_field_} field must be {width} pixels by {height} pixels",
      "email": "The {_field_} field must be a valid email",
      "excluded": "The {_field_} field is not a valid value",
      "ext": "The {_field_} field is not a valid file",
      "image": "The {_field_} field must be an image",
      "integer": "The {_field_} field must be an integer",
      "length": "The {_field_} field must be {length} long",
      "max_value": "The {_field_} field must be {max} or less",
      "max": "The {_field_} field may not be greater than {length} characters",
      "mimes": "The {_field_} field must have a valid file type",
      "min_value": "The {_field_} field must be {min} or more",
      "min": "The {_field_} field must be at least {length} characters",
      "numeric": "The {_field_} field may only contain numeric characters",
      "oneOf": "The {_field_} field is not a valid value",
      "regex": "The {_field_} field format is invalid",
      "required_if": "The {_field_} field is required",
      "required": "The {_field_} field is required",
      "size": "The {_field_} field size must be less than {size}KB"
    }
  },
  fr: {
    "code": "fr",
    "messages": {
      "alpha": "Le champ {_field_} ne peut contenir que des lettres",
      "alpha_num": "Le champ {_field_} ne peut contenir que des caractères alpha-numériques",
      "alpha_dash": "Le champ {_field_} ne peut contenir que des caractères alpha-numériques, tirets ou soulignés",
      "alpha_spaces": "Le champ {_field_} ne peut contenir que des lettres ou des espaces",
      "between": "Le champ {_field_} doit être compris entre {min} et {max}",
      "confirmed": "Le champ {_field_} ne correspond pas",
      "digits": "Le champ {_field_} doit être un nombre entier de {length} chiffres",
      "dimensions": "Le champ {_field_} doit avoir une taille de {width} pixels par {height} pixels",
      "email": "Le champ {_field_} doit être une adresse e-mail valide",
      "excluded": "Le champ {_field_} doit être une valeur valide",
      "ext": "Le champ {_field_} doit être un fichier valide",
      "image": "Le champ {_field_} doit être une image",
      "integer": "Le champ {_field_} doit être un entier",
      "length": "Le champ {_field_} doit contenir {length} caractères",
      "max_value": "Le champ {_field_} doit avoir une valeur de {max} ou moins",
      "max": "Le champ {_field_} ne peut pas contenir plus de {length} caractères",
      "mimes": "Le champ {_field_} doit avoir un type MIME valide",
      "min_value": "Le champ {_field_} doit avoir une valeur de {min} ou plus",
      "min": "Le champ {_field_} doit contenir au minimum {length} caractères",
      "numeric": "Le champ {_field_} ne peut contenir que des chiffres",
      "oneOf": "Le champ {_field_} doit être une valeur valide",
      "regex": "Le champ {_field_} est invalide",
      "required": "Le champ {_field_} est obligatoire",
      "required_if": "Le champ {_field_} est obligatoire lorsque {target} possède cette valeur",
      "size": "Le champ {_field_} doit avoir un poids inférieur à {size}KB"
    }
  }
});
"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function decodeUnicode(str) {
  return decodeURIComponent(atob(str).split("").map(function (c) {
    return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
} // run init script


function initForm(app) {
  // Set VeeValidate language based on the lang parameter
  VeeValidate.localize(app.dataset.lang);
  var componentOptions = app.dataset.options;
  var parsedOptions = {};

  if (componentOptions) {
    var fn = new Function("return (".concat(decodeUnicode(componentOptions), ");"));
    parsedOptions = fn();

    if (!parsedOptions) {
      console.log("Could not parse the componentOptions object. Make sure your object is well formed.");
    }
  }

  var _parsedOptions = parsedOptions,
      parsedData = _parsedOptions.data,
      parsedMethods = _parsedOptions.methods,
      parsedRest = _objectWithoutProperties(_parsedOptions, ["data", "methods"]);

  var objData = parsedData;

  if (typeof parsedData === "function") {
    objData = parsedData();
  }

  var defaultFormData = {
    submitting: false,
    submitSuccess: false,
    successMessage: undefined,
    submitError: false,
    submitValidationErrors: false,
    serverValidationMessage: undefined,
    serverErrorMessage: undefined,
    responseData: undefined
  };
  Vue.component(app.dataset.name, function (resolve) {
    resolve(_objectSpread(_objectSpread({}, parsedRest), {}, {
      template: "#".concat(app.dataset.name),
      data: function data() {
        return _objectSpread(_objectSpread({}, objData), {}, {
          form: _objectSpread({}, defaultFormData)
        });
      },
      methods: _objectSpread(_objectSpread({
        // default method that return the data to be submitted to the server
        // this was added first to allow the Administrator to edit this function on the OC Admin
        submitData: function submitData() {
          return _objectSpread({}, this.$data);
        }
      }, parsedMethods), {}, {
        formReset: function formReset() {
          this.form = _objectSpread({}, defaultFormData); // also reset the VeeValidate observer

          this.$refs.obs.reset();
        },
        formHandleSubmit: function formHandleSubmit(e) {
          var _this = this;

          e.preventDefault();
          var vm = this; // keep a reference to the VeeValidate observer

          var observer = vm.$refs.obs;
          observer.validate().then(function (valid) {
            if (valid) {
              var action = vm.$refs.form.getAttribute("action"); // set form vue data

              vm.form.submitting = true;
              var formData = new FormData();
              formData.append("__RequestVerificationToken", vm.$refs.form.querySelector('input[name="__RequestVerificationToken"]').value);

              if ((typeof grecaptcha === "undefined" ? "undefined" : _typeof(grecaptcha)) == "object") {
                formData.append("recaptcha", grecaptcha.getResponse());
              }

              var submitData = vm.submitData();

              for (var key in submitData) {
                formData.append(key, submitData[key]);
              } // iterate all file inputs and add the files to the request


              $(_this.$refs.form).find("input[type=file]").each(function () {
                var _iterator = _createForOfIteratorHelper(this.files),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var file = _step.value;
                    formData.append(file.name, file);
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              });
              $.ajax({
                type: "POST",
                url: action,
                data: formData,
                cache: false,
                dataType: "json",
                // expect json from the server
                processData: false,
                //tell jquery not to process data
                contentType: false,
                //tell jquery not to set content-type
                success: function success(data) {
                  vm.form = _objectSpread({}, defaultFormData);
                  vm.form.responseData = data; // if there are validation errors on the form, display them.

                  if (data.validationError) {
                    //legacy
                    if (data.errors["serverValidationMessage"] != null) {
                      vm.form.serverValidationMessage = data.errors["serverValidationMessage"];
                    }

                    vm.form.submitValidationError = true;
                    observer.setErrors(data.errors);
                    return;
                  } // if the server sends a redirect, reload the window


                  if (data.redirect) {
                    window.location.href = data.redirect;
                    return;
                  }

                  vm.form.submitSuccess = true;
                  vm.form.successMessage = data.successMessage;
                  return;
                },
                error: function error(xhr, statusText) {
                  vm.form = _objectSpread({}, defaultFormData);
                  vm.form.submitError = true;
                  vm.form.serverErrorMessage = "".concat(xhr.status, " ").concat(statusText);
                }
              });
            }
          });
          return false;
        }
      })
    }));
  }); // run the vue-form init script provided in the OC admin ui

  var initScript = app.dataset.initScript;

  if (initScript) {
    var initFn = new Function(decodeUnicode(initScript));
    initFn();
  }
} // look for all vue forms when this script is loaded and initialize them


document.querySelectorAll(".vue-form").forEach(initForm);
document.addEventListener("DOMContentLoaded", function (event) {
  document.querySelectorAll(".vue-app-instance").forEach(function (elem) {
    new Vue({
      el: elem
    });
  });
  document.querySelectorAll(".vuetify-app-instance").forEach(function (elem) {
    new Vue({
      el: elem,
      vuetify: new Vuetify()
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZlZXZhbGlkYXRlLXNldHVwLmpzIiwidnVlLWZvcm1zLmpzIl0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCIsIlZlZVZhbGlkYXRlIiwiVmFsaWRhdGlvblByb3ZpZGVyIiwiVmFsaWRhdGlvbk9ic2VydmVyIiwibG9jYWxpemUiLCJlbiIsImZyIiwiZGVjb2RlVW5pY29kZSIsInN0ciIsImRlY29kZVVSSUNvbXBvbmVudCIsImF0b2IiLCJzcGxpdCIsIm1hcCIsImMiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJzbGljZSIsImpvaW4iLCJpbml0Rm9ybSIsImFwcCIsImRhdGFzZXQiLCJsYW5nIiwiY29tcG9uZW50T3B0aW9ucyIsIm9wdGlvbnMiLCJwYXJzZWRPcHRpb25zIiwiZm4iLCJGdW5jdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJwYXJzZWREYXRhIiwiZGF0YSIsInBhcnNlZE1ldGhvZHMiLCJtZXRob2RzIiwicGFyc2VkUmVzdCIsIm9iakRhdGEiLCJkZWZhdWx0Rm9ybURhdGEiLCJzdWJtaXR0aW5nIiwic3VibWl0U3VjY2VzcyIsInN1Y2Nlc3NNZXNzYWdlIiwidW5kZWZpbmVkIiwic3VibWl0RXJyb3IiLCJzdWJtaXRWYWxpZGF0aW9uRXJyb3JzIiwic2VydmVyVmFsaWRhdGlvbk1lc3NhZ2UiLCJzZXJ2ZXJFcnJvck1lc3NhZ2UiLCJyZXNwb25zZURhdGEiLCJuYW1lIiwicmVzb2x2ZSIsInRlbXBsYXRlIiwiZm9ybSIsInN1Ym1pdERhdGEiLCIkZGF0YSIsImZvcm1SZXNldCIsIiRyZWZzIiwib2JzIiwicmVzZXQiLCJmb3JtSGFuZGxlU3VibWl0IiwiZSIsInByZXZlbnREZWZhdWx0Iiwidm0iLCJvYnNlcnZlciIsInZhbGlkYXRlIiwidGhlbiIsInZhbGlkIiwiYWN0aW9uIiwiZ2V0QXR0cmlidXRlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInF1ZXJ5U2VsZWN0b3IiLCJ2YWx1ZSIsImdyZWNhcHRjaGEiLCJnZXRSZXNwb25zZSIsImtleSIsIiQiLCJmaW5kIiwiZWFjaCIsImZpbGVzIiwiZmlsZSIsImFqYXgiLCJ0eXBlIiwidXJsIiwiY2FjaGUiLCJkYXRhVHlwZSIsInByb2Nlc3NEYXRhIiwiY29udGVudFR5cGUiLCJzdWNjZXNzIiwidmFsaWRhdGlvbkVycm9yIiwiZXJyb3JzIiwic3VibWl0VmFsaWRhdGlvbkVycm9yIiwic2V0RXJyb3JzIiwicmVkaXJlY3QiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJlcnJvciIsInhociIsInN0YXR1c1RleHQiLCJzdGF0dXMiLCJpbml0U2NyaXB0IiwiaW5pdEZuIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImVsZW0iLCJlbCIsInZ1ZXRpZnkiLCJWdWV0aWZ5Il0sIm1hcHBpbmdzIjoiOzs7OztBQUNBO0FBQ0FBLEdBQUcsQ0FBQ0MsU0FBSixDQUFjLHFCQUFkLEVBQXFDQyxXQUFXLENBQUNDLGtCQUFqRDtBQUNBSCxHQUFHLENBQUNDLFNBQUosQ0FBYyxxQkFBZCxFQUFxQ0MsV0FBVyxDQUFDRSxrQkFBakQsRSxDQUVBOztBQUNBRixXQUFXLENBQUNHLFFBQVosQ0FBcUI7QUFDbkJDLEVBQUFBLEVBQUUsRUFBQztBQUNELFlBQVEsSUFEUDtBQUVELGdCQUFZO0FBQ1YsZUFBUyw0REFEQztBQUVWLG1CQUFhLCtEQUZIO0FBR1Ysb0JBQWMsNEZBSEo7QUFJVixzQkFBZ0IsOEVBSk47QUFLVixpQkFBVyxxREFMRDtBQU1WLG1CQUFhLGlEQU5IO0FBT1YsZ0JBQVUseUVBUEE7QUFRVixvQkFBYywrREFSSjtBQVNWLGVBQVMsMkNBVEM7QUFVVixrQkFBWSwwQ0FWRjtBQVdWLGFBQU8seUNBWEc7QUFZVixlQUFTLHNDQVpDO0FBYVYsaUJBQVcsd0NBYkQ7QUFjVixnQkFBVSwyQ0FkQTtBQWVWLG1CQUFhLDJDQWZIO0FBZ0JWLGFBQU8saUVBaEJHO0FBaUJWLGVBQVMsaURBakJDO0FBa0JWLG1CQUFhLDJDQWxCSDtBQW1CVixhQUFPLDBEQW5CRztBQW9CVixpQkFBVyx5REFwQkQ7QUFxQlYsZUFBUywwQ0FyQkM7QUFzQlYsZUFBUyx1Q0F0QkM7QUF1QlYscUJBQWUsaUNBdkJMO0FBd0JWLGtCQUFZLGlDQXhCRjtBQXlCVixjQUFRO0FBekJFO0FBRlgsR0FEZ0I7QUErQm5CQyxFQUFBQSxFQUFFLEVBQUU7QUFDRixZQUFRLElBRE47QUFFRixnQkFBWTtBQUNWLGVBQVMscURBREM7QUFFVixtQkFBYSx5RUFGSDtBQUdWLG9CQUFjLDhGQUhKO0FBSVYsc0JBQWdCLG9FQUpOO0FBS1YsaUJBQVcsMkRBTEQ7QUFNVixtQkFBYSxzQ0FOSDtBQU9WLGdCQUFVLG9FQVBBO0FBUVYsb0JBQWMsZ0ZBUko7QUFTVixlQUFTLHdEQVRDO0FBVVYsa0JBQVksZ0RBVkY7QUFXVixhQUFPLGdEQVhHO0FBWVYsZUFBUyx3Q0FaQztBQWFWLGlCQUFXLHdDQWJEO0FBY1YsZ0JBQVUsc0RBZEE7QUFlVixtQkFBYSw0REFmSDtBQWdCVixhQUFPLHFFQWhCRztBQWlCVixlQUFTLG1EQWpCQztBQWtCVixtQkFBYSwyREFsQkg7QUFtQlYsYUFBTyxpRUFuQkc7QUFvQlYsaUJBQVcsc0RBcEJEO0FBcUJWLGVBQVMsZ0RBckJDO0FBc0JWLGVBQVMsaUNBdEJDO0FBdUJWLGtCQUFZLG9DQXZCRjtBQXdCVixxQkFBZSwwRUF4Qkw7QUF5QlYsY0FBUTtBQXpCRTtBQUZWO0FBL0JlLENBQXJCO0FDTkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsU0FBU0MsYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFDMUIsU0FBT0Msa0JBQWtCLENBQ3ZCQyxJQUFJLENBQUNGLEdBQUQsQ0FBSixDQUNHRyxLQURILENBQ1MsRUFEVCxFQUVHQyxHQUZILENBRU8sVUFBVUMsQ0FBVixFQUFhO0FBQ2hCLFdBQU8sTUFBTSxDQUFDLE9BQU9BLENBQUMsQ0FBQ0MsVUFBRixDQUFhLENBQWIsRUFBZ0JDLFFBQWhCLENBQXlCLEVBQXpCLENBQVIsRUFBc0NDLEtBQXRDLENBQTRDLENBQUMsQ0FBN0MsQ0FBYjtBQUNELEdBSkgsRUFLR0MsSUFMSCxDQUtRLEVBTFIsQ0FEdUIsQ0FBekI7QUFRRCxDLENBRUQ7OztBQUNBLFNBQVNDLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQ3JCO0FBQ0FsQixFQUFBQSxXQUFXLENBQUNHLFFBQVosQ0FBcUJlLEdBQUcsQ0FBQ0MsT0FBSixDQUFZQyxJQUFqQztBQUVBLE1BQUlDLGdCQUFnQixHQUFHSCxHQUFHLENBQUNDLE9BQUosQ0FBWUcsT0FBbkM7QUFFQSxNQUFJQyxhQUFhLEdBQUcsRUFBcEI7O0FBQ0EsTUFBSUYsZ0JBQUosRUFBc0I7QUFDcEIsUUFBTUcsRUFBRSxHQUFHLElBQUlDLFFBQUosbUJBQXdCbkIsYUFBYSxDQUFDZSxnQkFBRCxDQUFyQyxRQUFYO0FBQ0FFLElBQUFBLGFBQWEsR0FBR0MsRUFBRSxFQUFsQjs7QUFDQSxRQUFJLENBQUNELGFBQUwsRUFBb0I7QUFDbEJHLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUNFLG9GQURGO0FBR0Q7QUFDRjs7QUFFRCx1QkFJSUosYUFKSjtBQUFBLE1BQ1FLLFVBRFIsa0JBQ0VDLElBREY7QUFBQSxNQUVXQyxhQUZYLGtCQUVFQyxPQUZGO0FBQUEsTUFHS0MsVUFITDs7QUFLQSxNQUFJQyxPQUFPLEdBQUdMLFVBQWQ7O0FBQ0EsTUFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ3BDSyxJQUFBQSxPQUFPLEdBQUdMLFVBQVUsRUFBcEI7QUFDRDs7QUFDRCxNQUFNTSxlQUFlLEdBQUc7QUFDdEJDLElBQUFBLFVBQVUsRUFBRSxLQURVO0FBRXRCQyxJQUFBQSxhQUFhLEVBQUUsS0FGTztBQUd0QkMsSUFBQUEsY0FBYyxFQUFFQyxTQUhNO0FBSXRCQyxJQUFBQSxXQUFXLEVBQUUsS0FKUztBQUt0QkMsSUFBQUEsc0JBQXNCLEVBQUUsS0FMRjtBQU10QkMsSUFBQUEsdUJBQXVCLEVBQUVILFNBTkg7QUFPdEJJLElBQUFBLGtCQUFrQixFQUFFSixTQVBFO0FBUXRCSyxJQUFBQSxZQUFZLEVBQUVMO0FBUlEsR0FBeEI7QUFXQXhDLEVBQUFBLEdBQUcsQ0FBQ0MsU0FBSixDQUFjbUIsR0FBRyxDQUFDQyxPQUFKLENBQVl5QixJQUExQixFQUFnQyxVQUFVQyxPQUFWLEVBQW1CO0FBQ2pEQSxJQUFBQSxPQUFPLGlDQUVGYixVQUZFO0FBR0xjLE1BQUFBLFFBQVEsYUFBTTVCLEdBQUcsQ0FBQ0MsT0FBSixDQUFZeUIsSUFBbEIsQ0FISDtBQUlMZixNQUFBQSxJQUFJLEVBQUUsZ0JBQVk7QUFDaEIsK0NBQ0tJLE9BREw7QUFFRWMsVUFBQUEsSUFBSSxvQkFBT2IsZUFBUDtBQUZOO0FBSUQsT0FUSTtBQVVMSCxNQUFBQSxPQUFPO0FBQ0w7QUFDQTtBQUNBaUIsUUFBQUEsVUFISyx3QkFHUTtBQUNYLG1DQUFZLEtBQUtDLEtBQWpCO0FBQ0Q7QUFMSSxTQU1GbkIsYUFORTtBQU9Mb0IsUUFBQUEsU0FQSyx1QkFPTztBQUNWLGVBQUtILElBQUwscUJBQWlCYixlQUFqQixFQURVLENBRVY7O0FBQ0EsZUFBS2lCLEtBQUwsQ0FBV0MsR0FBWCxDQUFlQyxLQUFmO0FBQ0QsU0FYSTtBQVlMQyxRQUFBQSxnQkFaSyw0QkFZWUMsQ0FaWixFQVllO0FBQUE7O0FBQ2xCQSxVQUFBQSxDQUFDLENBQUNDLGNBQUY7QUFDQSxjQUFNQyxFQUFFLEdBQUcsSUFBWCxDQUZrQixDQUdsQjs7QUFDQSxjQUFNQyxRQUFRLEdBQUdELEVBQUUsQ0FBQ04sS0FBSCxDQUFTQyxHQUExQjtBQUNBTSxVQUFBQSxRQUFRLENBQUNDLFFBQVQsR0FBb0JDLElBQXBCLENBQXlCLFVBQUNDLEtBQUQsRUFBVztBQUNsQyxnQkFBSUEsS0FBSixFQUFXO0FBQ1Qsa0JBQU1DLE1BQU0sR0FBR0wsRUFBRSxDQUFDTixLQUFILENBQVNKLElBQVQsQ0FBY2dCLFlBQWQsQ0FBMkIsUUFBM0IsQ0FBZixDQURTLENBR1Q7O0FBQ0FOLGNBQUFBLEVBQUUsQ0FBQ1YsSUFBSCxDQUFRWixVQUFSLEdBQXFCLElBQXJCO0FBRUEsa0JBQUk2QixRQUFRLEdBQUcsSUFBSUMsUUFBSixFQUFmO0FBQ0FELGNBQUFBLFFBQVEsQ0FBQ0UsTUFBVCxDQUFnQiw0QkFBaEIsRUFBOENULEVBQUUsQ0FBQ04sS0FBSCxDQUFTSixJQUFULENBQWNvQixhQUFkLENBQzVDLDBDQUQ0QyxFQUU1Q0MsS0FGRjs7QUFHQSxrQkFBSSxRQUFPQyxVQUFQLHlDQUFPQSxVQUFQLE1BQXFCLFFBQXpCLEVBQW1DO0FBQ2pDTCxnQkFBQUEsUUFBUSxDQUFDRSxNQUFULENBQWdCLFdBQWhCLEVBQTZCRyxVQUFVLENBQUNDLFdBQVgsRUFBN0I7QUFDRDs7QUFFRCxrQkFBSXRCLFVBQVUsR0FBR1MsRUFBRSxDQUFDVCxVQUFILEVBQWpCOztBQUNBLG1CQUFLLElBQU11QixHQUFYLElBQWtCdkIsVUFBbEIsRUFBOEI7QUFDNUJnQixnQkFBQUEsUUFBUSxDQUFDRSxNQUFULENBQWdCSyxHQUFoQixFQUFxQnZCLFVBQVUsQ0FBQ3VCLEdBQUQsQ0FBL0I7QUFDRCxlQWpCUSxDQW1CVDs7O0FBQ0FDLGNBQUFBLENBQUMsQ0FBQyxLQUFJLENBQUNyQixLQUFMLENBQVdKLElBQVosQ0FBRCxDQUFtQjBCLElBQW5CLENBQXdCLGtCQUF4QixFQUE0Q0MsSUFBNUMsQ0FBaUQsWUFBVTtBQUFBLDJEQUN0QyxLQUFLQyxLQURpQztBQUFBOztBQUFBO0FBQ3pELHNFQUErQjtBQUFBLHdCQUFwQkMsSUFBb0I7QUFDN0JaLG9CQUFBQSxRQUFRLENBQUNFLE1BQVQsQ0FBZ0JVLElBQUksQ0FBQ2hDLElBQXJCLEVBQTJCZ0MsSUFBM0I7QUFDRDtBQUh3RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSTFELGVBSkQ7QUFNQUosY0FBQUEsQ0FBQyxDQUFDSyxJQUFGLENBQU87QUFDTEMsZ0JBQUFBLElBQUksRUFBRSxNQUREO0FBRUxDLGdCQUFBQSxHQUFHLEVBQUVqQixNQUZBO0FBR0xqQyxnQkFBQUEsSUFBSSxFQUFFbUMsUUFIRDtBQUlMZ0IsZ0JBQUFBLEtBQUssRUFBRSxLQUpGO0FBS0xDLGdCQUFBQSxRQUFRLEVBQUUsTUFMTDtBQUthO0FBQ2xCQyxnQkFBQUEsV0FBVyxFQUFFLEtBTlI7QUFNZTtBQUNwQkMsZ0JBQUFBLFdBQVcsRUFBRSxLQVBSO0FBT2U7QUFDcEJDLGdCQUFBQSxPQUFPLEVBQUUsaUJBQVV2RCxJQUFWLEVBQWdCO0FBQ3ZCNEIsa0JBQUFBLEVBQUUsQ0FBQ1YsSUFBSCxxQkFBZWIsZUFBZjtBQUNBdUIsa0JBQUFBLEVBQUUsQ0FBQ1YsSUFBSCxDQUFRSixZQUFSLEdBQXVCZCxJQUF2QixDQUZ1QixDQUd2Qjs7QUFDQSxzQkFBSUEsSUFBSSxDQUFDd0QsZUFBVCxFQUEwQjtBQUN4QjtBQUNBLHdCQUFJeEQsSUFBSSxDQUFDeUQsTUFBTCxDQUFZLHlCQUFaLEtBQTBDLElBQTlDLEVBQW9EO0FBQ2xEN0Isc0JBQUFBLEVBQUUsQ0FBQ1YsSUFBSCxDQUFRTix1QkFBUixHQUNFWixJQUFJLENBQUN5RCxNQUFMLENBQVkseUJBQVosQ0FERjtBQUVEOztBQUNEN0Isb0JBQUFBLEVBQUUsQ0FBQ1YsSUFBSCxDQUFRd0MscUJBQVIsR0FBZ0MsSUFBaEM7QUFDQTdCLG9CQUFBQSxRQUFRLENBQUM4QixTQUFULENBQW1CM0QsSUFBSSxDQUFDeUQsTUFBeEI7QUFDQTtBQUNELG1CQWJzQixDQWV2Qjs7O0FBQ0Esc0JBQUl6RCxJQUFJLENBQUM0RCxRQUFULEVBQW1CO0FBQ2pCQyxvQkFBQUEsTUFBTSxDQUFDQyxRQUFQLENBQWdCQyxJQUFoQixHQUF1Qi9ELElBQUksQ0FBQzRELFFBQTVCO0FBQ0E7QUFDRDs7QUFFRGhDLGtCQUFBQSxFQUFFLENBQUNWLElBQUgsQ0FBUVgsYUFBUixHQUF3QixJQUF4QjtBQUNBcUIsa0JBQUFBLEVBQUUsQ0FBQ1YsSUFBSCxDQUFRVixjQUFSLEdBQXlCUixJQUFJLENBQUNRLGNBQTlCO0FBQ0E7QUFDRCxpQkFoQ0k7QUFpQ0x3RCxnQkFBQUEsS0FBSyxFQUFFLGVBQVVDLEdBQVYsRUFBZUMsVUFBZixFQUEyQjtBQUNoQ3RDLGtCQUFBQSxFQUFFLENBQUNWLElBQUgscUJBQWViLGVBQWY7QUFDQXVCLGtCQUFBQSxFQUFFLENBQUNWLElBQUgsQ0FBUVIsV0FBUixHQUFzQixJQUF0QjtBQUNBa0Isa0JBQUFBLEVBQUUsQ0FBQ1YsSUFBSCxDQUFRTCxrQkFBUixhQUFnQ29ELEdBQUcsQ0FBQ0UsTUFBcEMsY0FBOENELFVBQTlDO0FBQ0Q7QUFyQ0ksZUFBUDtBQXVDRDtBQUNGLFdBbkVEO0FBb0VBLGlCQUFPLEtBQVA7QUFDRDtBQXRGSTtBQVZGLE9BQVA7QUFtR0QsR0FwR0QsRUFyQ3FCLENBMklyQjs7QUFDQSxNQUFJRSxVQUFVLEdBQUcvRSxHQUFHLENBQUNDLE9BQUosQ0FBWThFLFVBQTdCOztBQUNBLE1BQUlBLFVBQUosRUFBZ0I7QUFDZCxRQUFNQyxNQUFNLEdBQUcsSUFBSXpFLFFBQUosQ0FBYW5CLGFBQWEsQ0FBQzJGLFVBQUQsQ0FBMUIsQ0FBZjtBQUNBQyxJQUFBQSxNQUFNO0FBQ1A7QUFDRixDLENBRUQ7OztBQUNBQyxRQUFRLENBQUNDLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDQyxPQUF2QyxDQUErQ3BGLFFBQS9DO0FBRUFrRixRQUFRLENBQUNHLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxVQUFVQyxLQUFWLEVBQWlCO0FBRTdESixFQUFBQSxRQUFRLENBQUNDLGdCQUFULENBQTBCLG1CQUExQixFQUErQ0MsT0FBL0MsQ0FBdUQsVUFBVUcsSUFBVixFQUFnQjtBQUNyRSxRQUFJMUcsR0FBSixDQUFRO0FBQ04yRyxNQUFBQSxFQUFFLEVBQUVEO0FBREUsS0FBUjtBQUdELEdBSkQ7QUFNQUwsRUFBQUEsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQix1QkFBMUIsRUFBbURDLE9BQW5ELENBQTJELFVBQVVHLElBQVYsRUFBZ0I7QUFDekUsUUFBSTFHLEdBQUosQ0FBUTtBQUNOMkcsTUFBQUEsRUFBRSxFQUFFRCxJQURFO0FBRU5FLE1BQUFBLE9BQU8sRUFBRSxJQUFJQyxPQUFKO0FBRkgsS0FBUjtBQUlELEdBTEQ7QUFPRCxDQWZEIiwiZmlsZSI6InZ1ZS1mb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vLyByZWdpc3RlciBWZWVWYWxpZGF0ZSBjb21wb25lbnRzIGdsb2JhbGx5XHJcblZ1ZS5jb21wb25lbnQoJ3ZhbGlkYXRpb24tcHJvdmlkZXInLCBWZWVWYWxpZGF0ZS5WYWxpZGF0aW9uUHJvdmlkZXIpO1xyXG5WdWUuY29tcG9uZW50KCd2YWxpZGF0aW9uLW9ic2VydmVyJywgVmVlVmFsaWRhdGUuVmFsaWRhdGlvbk9ic2VydmVyKTsgXHJcblxyXG4vLyBpbmNsdWRlIGRlZmF1bHQgZW5nbGlzaCBhbmQgZnJlbmNoIHRyYW5zbGF0aW9ucy5cclxuVmVlVmFsaWRhdGUubG9jYWxpemUoe1xyXG4gIGVuOntcclxuICAgIFwiY29kZVwiOiBcImVuXCIsXHJcbiAgICBcIm1lc3NhZ2VzXCI6IHtcclxuICAgICAgXCJhbHBoYVwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnNcIixcclxuICAgICAgXCJhbHBoYV9udW1cIjogXCJUaGUge19maWVsZF99IGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzXCIsXHJcbiAgICAgIFwiYWxwaGFfZGFzaFwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzIGFzIHdlbGwgYXMgZGFzaGVzIGFuZCB1bmRlcnNjb3Jlc1wiLFxyXG4gICAgICBcImFscGhhX3NwYWNlc1wiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBzcGFjZXNcIixcclxuICAgICAgXCJiZXR3ZWVuXCI6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBtdXN0IGJlIGJldHdlZW4ge21pbn0gYW5kIHttYXh9XCIsXHJcbiAgICAgIFwiY29uZmlybWVkXCI6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBjb25maXJtYXRpb24gZG9lcyBub3QgbWF0Y2hcIixcclxuICAgICAgXCJkaWdpdHNcIjogXCJUaGUge19maWVsZF99IGZpZWxkIG11c3QgYmUgbnVtZXJpYyBhbmQgZXhhY3RseSBjb250YWluIHtsZW5ndGh9IGRpZ2l0c1wiLFxyXG4gICAgICBcImRpbWVuc2lvbnNcIjogXCJUaGUge19maWVsZF99IGZpZWxkIG11c3QgYmUge3dpZHRofSBwaXhlbHMgYnkge2hlaWdodH0gcGl4ZWxzXCIsXHJcbiAgICAgIFwiZW1haWxcIjogXCJUaGUge19maWVsZF99IGZpZWxkIG11c3QgYmUgYSB2YWxpZCBlbWFpbFwiLFxyXG4gICAgICBcImV4Y2x1ZGVkXCI6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBpcyBub3QgYSB2YWxpZCB2YWx1ZVwiLFxyXG4gICAgICBcImV4dFwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgaXMgbm90IGEgdmFsaWQgZmlsZVwiLFxyXG4gICAgICBcImltYWdlXCI6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBtdXN0IGJlIGFuIGltYWdlXCIsXHJcbiAgICAgIFwiaW50ZWdlclwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIsXHJcbiAgICAgIFwibGVuZ3RoXCI6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBtdXN0IGJlIHtsZW5ndGh9IGxvbmdcIixcclxuICAgICAgXCJtYXhfdmFsdWVcIjogXCJUaGUge19maWVsZF99IGZpZWxkIG11c3QgYmUge21heH0gb3IgbGVzc1wiLFxyXG4gICAgICBcIm1heFwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4ge2xlbmd0aH0gY2hhcmFjdGVyc1wiLFxyXG4gICAgICBcIm1pbWVzXCI6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBtdXN0IGhhdmUgYSB2YWxpZCBmaWxlIHR5cGVcIixcclxuICAgICAgXCJtaW5fdmFsdWVcIjogXCJUaGUge19maWVsZF99IGZpZWxkIG11c3QgYmUge21pbn0gb3IgbW9yZVwiLFxyXG4gICAgICBcIm1pblwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSBhdCBsZWFzdCB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXHJcbiAgICAgIFwibnVtZXJpY1wiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IG9ubHkgY29udGFpbiBudW1lcmljIGNoYXJhY3RlcnNcIixcclxuICAgICAgXCJvbmVPZlwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgaXMgbm90IGEgdmFsaWQgdmFsdWVcIixcclxuICAgICAgXCJyZWdleFwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgZm9ybWF0IGlzIGludmFsaWRcIixcclxuICAgICAgXCJyZXF1aXJlZF9pZlwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgaXMgcmVxdWlyZWRcIixcclxuICAgICAgXCJyZXF1aXJlZFwiOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgaXMgcmVxdWlyZWRcIixcclxuICAgICAgXCJzaXplXCI6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBzaXplIG11c3QgYmUgbGVzcyB0aGFuIHtzaXplfUtCXCJcclxuICAgIH1cclxuICB9LFxyXG4gIGZyOiB7XHJcbiAgICBcImNvZGVcIjogXCJmclwiLFxyXG4gICAgXCJtZXNzYWdlc1wiOiB7XHJcbiAgICAgIFwiYWxwaGFcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gbmUgcGV1dCBjb250ZW5pciBxdWUgZGVzIGxldHRyZXNcIixcclxuICAgICAgXCJhbHBoYV9udW1cIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gbmUgcGV1dCBjb250ZW5pciBxdWUgZGVzIGNhcmFjdMOocmVzIGFscGhhLW51bcOpcmlxdWVzXCIsXHJcbiAgICAgIFwiYWxwaGFfZGFzaFwiOiBcIkxlIGNoYW1wIHtfZmllbGRffSBuZSBwZXV0IGNvbnRlbmlyIHF1ZSBkZXMgY2FyYWN0w6hyZXMgYWxwaGEtbnVtw6lyaXF1ZXMsIHRpcmV0cyBvdSBzb3VsaWduw6lzXCIsXHJcbiAgICAgIFwiYWxwaGFfc3BhY2VzXCI6IFwiTGUgY2hhbXAge19maWVsZF99IG5lIHBldXQgY29udGVuaXIgcXVlIGRlcyBsZXR0cmVzIG91IGRlcyBlc3BhY2VzXCIsXHJcbiAgICAgIFwiYmV0d2VlblwiOiBcIkxlIGNoYW1wIHtfZmllbGRffSBkb2l0IMOqdHJlIGNvbXByaXMgZW50cmUge21pbn0gZXQge21heH1cIixcclxuICAgICAgXCJjb25maXJtZWRcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gbmUgY29ycmVzcG9uZCBwYXNcIixcclxuICAgICAgXCJkaWdpdHNcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gZG9pdCDDqnRyZSB1biBub21icmUgZW50aWVyIGRlIHtsZW5ndGh9IGNoaWZmcmVzXCIsXHJcbiAgICAgIFwiZGltZW5zaW9uc1wiOiBcIkxlIGNoYW1wIHtfZmllbGRffSBkb2l0IGF2b2lyIHVuZSB0YWlsbGUgZGUge3dpZHRofSBwaXhlbHMgcGFyIHtoZWlnaHR9IHBpeGVsc1wiLFxyXG4gICAgICBcImVtYWlsXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGRvaXQgw6p0cmUgdW5lIGFkcmVzc2UgZS1tYWlsIHZhbGlkZVwiLFxyXG4gICAgICBcImV4Y2x1ZGVkXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGRvaXQgw6p0cmUgdW5lIHZhbGV1ciB2YWxpZGVcIixcclxuICAgICAgXCJleHRcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gZG9pdCDDqnRyZSB1biBmaWNoaWVyIHZhbGlkZVwiLFxyXG4gICAgICBcImltYWdlXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGRvaXQgw6p0cmUgdW5lIGltYWdlXCIsXHJcbiAgICAgIFwiaW50ZWdlclwiOiBcIkxlIGNoYW1wIHtfZmllbGRffSBkb2l0IMOqdHJlIHVuIGVudGllclwiLFxyXG4gICAgICBcImxlbmd0aFwiOiBcIkxlIGNoYW1wIHtfZmllbGRffSBkb2l0IGNvbnRlbmlyIHtsZW5ndGh9IGNhcmFjdMOocmVzXCIsXHJcbiAgICAgIFwibWF4X3ZhbHVlXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGRvaXQgYXZvaXIgdW5lIHZhbGV1ciBkZSB7bWF4fSBvdSBtb2luc1wiLFxyXG4gICAgICBcIm1heFwiOiBcIkxlIGNoYW1wIHtfZmllbGRffSBuZSBwZXV0IHBhcyBjb250ZW5pciBwbHVzIGRlIHtsZW5ndGh9IGNhcmFjdMOocmVzXCIsXHJcbiAgICAgIFwibWltZXNcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gZG9pdCBhdm9pciB1biB0eXBlIE1JTUUgdmFsaWRlXCIsXHJcbiAgICAgIFwibWluX3ZhbHVlXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGRvaXQgYXZvaXIgdW5lIHZhbGV1ciBkZSB7bWlufSBvdSBwbHVzXCIsXHJcbiAgICAgIFwibWluXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGRvaXQgY29udGVuaXIgYXUgbWluaW11bSB7bGVuZ3RofSBjYXJhY3TDqHJlc1wiLFxyXG4gICAgICBcIm51bWVyaWNcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gbmUgcGV1dCBjb250ZW5pciBxdWUgZGVzIGNoaWZmcmVzXCIsXHJcbiAgICAgIFwib25lT2ZcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gZG9pdCDDqnRyZSB1bmUgdmFsZXVyIHZhbGlkZVwiLFxyXG4gICAgICBcInJlZ2V4XCI6IFwiTGUgY2hhbXAge19maWVsZF99IGVzdCBpbnZhbGlkZVwiLFxyXG4gICAgICBcInJlcXVpcmVkXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGVzdCBvYmxpZ2F0b2lyZVwiLFxyXG4gICAgICBcInJlcXVpcmVkX2lmXCI6IFwiTGUgY2hhbXAge19maWVsZF99IGVzdCBvYmxpZ2F0b2lyZSBsb3JzcXVlIHt0YXJnZXR9IHBvc3PDqGRlIGNldHRlIHZhbGV1clwiLFxyXG4gICAgICBcInNpemVcIjogXCJMZSBjaGFtcCB7X2ZpZWxkX30gZG9pdCBhdm9pciB1biBwb2lkcyBpbmbDqXJpZXVyIMOgIHtzaXplfUtCXCJcclxuICAgIH1cclxuICB9LFxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5mdW5jdGlvbiBkZWNvZGVVbmljb2RlKHN0cikge1xyXG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoXHJcbiAgICBhdG9iKHN0cilcclxuICAgICAgLnNwbGl0KFwiXCIpXHJcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICByZXR1cm4gXCIlXCIgKyAoXCIwMFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xyXG4gICAgICB9KVxyXG4gICAgICAuam9pbihcIlwiKVxyXG4gICk7XHJcbn1cclxuXHJcbi8vIHJ1biBpbml0IHNjcmlwdFxyXG5mdW5jdGlvbiBpbml0Rm9ybShhcHApIHtcclxuICAvLyBTZXQgVmVlVmFsaWRhdGUgbGFuZ3VhZ2UgYmFzZWQgb24gdGhlIGxhbmcgcGFyYW1ldGVyXHJcbiAgVmVlVmFsaWRhdGUubG9jYWxpemUoYXBwLmRhdGFzZXQubGFuZyk7XHJcblxyXG4gIGxldCBjb21wb25lbnRPcHRpb25zID0gYXBwLmRhdGFzZXQub3B0aW9ucztcclxuXHJcbiAgbGV0IHBhcnNlZE9wdGlvbnMgPSB7fTtcclxuICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xyXG4gICAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oYHJldHVybiAoJHtkZWNvZGVVbmljb2RlKGNvbXBvbmVudE9wdGlvbnMpfSk7YCk7XHJcbiAgICBwYXJzZWRPcHRpb25zID0gZm4oKTtcclxuICAgIGlmICghcGFyc2VkT3B0aW9ucykge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBcIkNvdWxkIG5vdCBwYXJzZSB0aGUgY29tcG9uZW50T3B0aW9ucyBvYmplY3QuIE1ha2Ugc3VyZSB5b3VyIG9iamVjdCBpcyB3ZWxsIGZvcm1lZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3Qge1xyXG4gICAgZGF0YTogcGFyc2VkRGF0YSxcclxuICAgIG1ldGhvZHM6IHBhcnNlZE1ldGhvZHMsXHJcbiAgICAuLi5wYXJzZWRSZXN0XHJcbiAgfSA9IHBhcnNlZE9wdGlvbnM7XHJcbiAgbGV0IG9iakRhdGEgPSBwYXJzZWREYXRhO1xyXG4gIGlmICh0eXBlb2YgcGFyc2VkRGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICBvYmpEYXRhID0gcGFyc2VkRGF0YSgpO1xyXG4gIH1cclxuICBjb25zdCBkZWZhdWx0Rm9ybURhdGEgPSB7XHJcbiAgICBzdWJtaXR0aW5nOiBmYWxzZSxcclxuICAgIHN1Ym1pdFN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgc3VjY2Vzc01lc3NhZ2U6IHVuZGVmaW5lZCxcclxuICAgIHN1Ym1pdEVycm9yOiBmYWxzZSxcclxuICAgIHN1Ym1pdFZhbGlkYXRpb25FcnJvcnM6IGZhbHNlLFxyXG4gICAgc2VydmVyVmFsaWRhdGlvbk1lc3NhZ2U6IHVuZGVmaW5lZCxcclxuICAgIHNlcnZlckVycm9yTWVzc2FnZTogdW5kZWZpbmVkLFxyXG4gICAgcmVzcG9uc2VEYXRhOiB1bmRlZmluZWQsXHJcbiAgfTtcclxuXHJcbiAgVnVlLmNvbXBvbmVudChhcHAuZGF0YXNldC5uYW1lLCBmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgcmVzb2x2ZSh7XHJcbiAgICAgIC8vIEZpcnN0IGJlY2F1c2UgdGhlIGVsZW1lbnRzIGJlbG93IHdpbGwgb3ZlcnJpZGVcclxuICAgICAgLi4ucGFyc2VkUmVzdCxcclxuICAgICAgdGVtcGxhdGU6IGAjJHthcHAuZGF0YXNldC5uYW1lfWAsXHJcbiAgICAgIGRhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4ub2JqRGF0YSxcclxuICAgICAgICAgIGZvcm06IHsgLi4uZGVmYXVsdEZvcm1EYXRhIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuICAgICAgbWV0aG9kczoge1xyXG4gICAgICAgIC8vIGRlZmF1bHQgbWV0aG9kIHRoYXQgcmV0dXJuIHRoZSBkYXRhIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgc2VydmVyXHJcbiAgICAgICAgLy8gdGhpcyB3YXMgYWRkZWQgZmlyc3QgdG8gYWxsb3cgdGhlIEFkbWluaXN0cmF0b3IgdG8gZWRpdCB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBPQyBBZG1pblxyXG4gICAgICAgIHN1Ym1pdERhdGEoKSB7XHJcbiAgICAgICAgICByZXR1cm4geyAuLi50aGlzLiRkYXRhIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAuLi5wYXJzZWRNZXRob2RzLFxyXG4gICAgICAgIGZvcm1SZXNldCgpIHtcclxuICAgICAgICAgIHRoaXMuZm9ybSA9IHsgLi4uZGVmYXVsdEZvcm1EYXRhIH07XHJcbiAgICAgICAgICAvLyBhbHNvIHJlc2V0IHRoZSBWZWVWYWxpZGF0ZSBvYnNlcnZlclxyXG4gICAgICAgICAgdGhpcy4kcmVmcy5vYnMucmVzZXQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvcm1IYW5kbGVTdWJtaXQoZSkge1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xyXG4gICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgVmVlVmFsaWRhdGUgb2JzZXJ2ZXJcclxuICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gdm0uJHJlZnMub2JzO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIudmFsaWRhdGUoKS50aGVuKCh2YWxpZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcclxuICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSB2bS4kcmVmcy5mb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBzZXQgZm9ybSB2dWUgZGF0YVxyXG4gICAgICAgICAgICAgIHZtLmZvcm0uc3VibWl0dGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIl9fUmVxdWVzdFZlcmlmaWNhdGlvblRva2VuXCIsIHZtLiRyZWZzLmZvcm0ucXVlcnlTZWxlY3RvcihcclxuICAgICAgICAgICAgICAgICdpbnB1dFtuYW1lPVwiX19SZXF1ZXN0VmVyaWZpY2F0aW9uVG9rZW5cIl0nXHJcbiAgICAgICAgICAgICAgKS52YWx1ZSlcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGdyZWNhcHRjaGEgPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwicmVjYXB0Y2hhXCIsIGdyZWNhcHRjaGEuZ2V0UmVzcG9uc2UoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgbGV0IHN1Ym1pdERhdGEgPSB2bS5zdWJtaXREYXRhKCk7XHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3VibWl0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgc3VibWl0RGF0YVtrZXldKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbGwgZmlsZSBpbnB1dHMgYW5kIGFkZCB0aGUgZmlsZXMgdG8gdGhlIHJlcXVlc3RcclxuICAgICAgICAgICAgICAkKHRoaXMuJHJlZnMuZm9ybSkuZmluZChcImlucHV0W3R5cGU9ZmlsZV1cIikuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIHRoaXMuZmlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZpbGUubmFtZSwgZmlsZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgICAgICAgdXJsOiBhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBmb3JtRGF0YSxcclxuICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIiwgLy8gZXhwZWN0IGpzb24gZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsIC8vdGVsbCBqcXVlcnkgbm90IHRvIHByb2Nlc3MgZGF0YVxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGZhbHNlLCAvL3RlbGwganF1ZXJ5IG5vdCB0byBzZXQgY29udGVudC10eXBlXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICB2bS5mb3JtID0geyAuLi5kZWZhdWx0Rm9ybURhdGEgfTtcclxuICAgICAgICAgICAgICAgICAgdm0uZm9ybS5yZXNwb25zZURhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgdmFsaWRhdGlvbiBlcnJvcnMgb24gdGhlIGZvcm0sIGRpc3BsYXkgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudmFsaWRhdGlvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sZWdhY3lcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcnNbXCJzZXJ2ZXJWYWxpZGF0aW9uTWVzc2FnZVwiXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2bS5mb3JtLnNlcnZlclZhbGlkYXRpb25NZXNzYWdlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5lcnJvcnNbXCJzZXJ2ZXJWYWxpZGF0aW9uTWVzc2FnZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdm0uZm9ybS5zdWJtaXRWYWxpZGF0aW9uRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLnNldEVycm9ycyhkYXRhLmVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2VydmVyIHNlbmRzIGEgcmVkaXJlY3QsIHJlbG9hZCB0aGUgd2luZG93XHJcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnJlZGlyZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkYXRhLnJlZGlyZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgdm0uZm9ybS5zdWJtaXRTdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgdm0uZm9ybS5zdWNjZXNzTWVzc2FnZSA9IGRhdGEuc3VjY2Vzc01lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgc3RhdHVzVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICB2bS5mb3JtID0geyAuLi5kZWZhdWx0Rm9ybURhdGEgfTtcclxuICAgICAgICAgICAgICAgICAgdm0uZm9ybS5zdWJtaXRFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIHZtLmZvcm0uc2VydmVyRXJyb3JNZXNzYWdlID0gYCR7eGhyLnN0YXR1c30gJHtzdGF0dXNUZXh0fWA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIHJ1biB0aGUgdnVlLWZvcm0gaW5pdCBzY3JpcHQgcHJvdmlkZWQgaW4gdGhlIE9DIGFkbWluIHVpXHJcbiAgbGV0IGluaXRTY3JpcHQgPSBhcHAuZGF0YXNldC5pbml0U2NyaXB0O1xyXG4gIGlmIChpbml0U2NyaXB0KSB7XHJcbiAgICBjb25zdCBpbml0Rm4gPSBuZXcgRnVuY3Rpb24oZGVjb2RlVW5pY29kZShpbml0U2NyaXB0KSk7XHJcbiAgICBpbml0Rm4oKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIGxvb2sgZm9yIGFsbCB2dWUgZm9ybXMgd2hlbiB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgYW5kIGluaXRpYWxpemUgdGhlbVxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnZ1ZS1mb3JtXCIpLmZvckVhY2goaW5pdEZvcm0pO1xyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudnVlLWFwcC1pbnN0YW5jZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICBuZXcgVnVlKHtcclxuICAgICAgZWw6IGVsZW0sXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi52dWV0aWZ5LWFwcC1pbnN0YW5jZVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICBuZXcgVnVlKHtcclxuICAgICAgZWw6IGVsZW0sXHJcbiAgICAgIHZ1ZXRpZnk6IG5ldyBWdWV0aWZ5KCksXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbn0pO1xyXG4iXX0=
